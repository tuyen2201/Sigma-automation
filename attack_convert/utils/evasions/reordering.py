import random
import re
from typing import List, Tuple

def parse_command(command: str) -> Tuple[str, List[str]]:
    """Parse command into executable and arguments, handling quotes and special characters."""
    tokens = []
    current = []
    in_quotes = False
    
    for char in command:
        if char == '"':
            in_quotes = not in_quotes
            current.append(char)
        elif char.isspace() and not in_quotes:
            if current:
                tokens.append(''.join(current))
                current = []
        else:
            current.append(char)
            
    if current:
        tokens.append(''.join(current))
        
    return tokens[0], tokens[1:] if len(tokens) > 1 else []

def is_order_dependent(args: List[str]) -> bool:
    """Check if arguments are order-dependent."""
    # Common patterns where order matters
    order_dependent_patterns = [
        r'^-[a-zA-Z]$',  # Single letter flags
        r'^--[a-zA-Z-]+$',  # Long form flags
        r'^/[a-zA-Z]$',  # Windows style flags
    ]
    
    # Check if any argument is a flag that requires a value
    for i, arg in enumerate(args):
        if any(re.match(pattern, arg) for pattern in order_dependent_patterns):
            # If this is the last argument or next argument is also a flag, it's safe to reorder
            if i == len(args) - 1 or any(re.match(pattern, args[i+1]) for pattern in order_dependent_patterns):
                continue
            return True
    return False

def is_safe_reordering(command: str, reordered: str) -> bool:
    """Check if a reordering preserves command functionality."""
    # Check if reordering breaks command structure
    if reordered.count('"') % 2 != 0:  # Unmatched quotes
        return False
        
    # Check if reordering breaks common command patterns
    if re.search(r'[<>|&]', reordered):  # Avoid breaking pipes and redirects
        return False
        
    # Check if reordering breaks command syntax
    if re.search(r'/[a-zA-Z]', reordered):  # Check for /command patterns
        return False

    # Check if command is still first
    if command.startswith('cmd') and not reordered.startswith('cmd'):
        return False

    # Check if /c is present in both original and reordered
    if '/c' in command and '/c' not in reordered:
        return False
        
    return True

def generate_reorderings(command: str) -> list[str]:
    """
    Generate multiple evasive variants using reordering techniques.
    These include reordering command parts while preserving functionality.
    """
    if not command:
        return []

    reorderings = []
    tokens = command.split()
    if len(tokens) < 2:
        return []

    # Special handling for cmd /c commands
    if tokens[0] == 'cmd' and len(tokens) >= 3:
        # Strategy 1: Move /c to end
        # Example: cmd /c assoc -> cmd assoc /c
        if tokens[1] == '/c':
            reordered_tokens = [tokens[0]] + tokens[2:] + [tokens[1]]
            reordered_cmd = " ".join(reordered_tokens)
            if is_safe_reordering(command, reordered_cmd):
                reorderings.append(reordered_cmd)

        # Strategy 2: Move /c after other flags
        # Example: cmd /c /v assoc -> cmd /v /c assoc
        if tokens[1] == '/c' and any(token.startswith('/') for token in tokens[2:]):
            other_flags = [token for token in tokens[2:] if token.startswith('/')]
            non_flags = [token for token in tokens[2:] if not token.startswith('/')]
            reordered_tokens = [tokens[0]] + other_flags + [tokens[1]] + non_flags
            reordered_cmd = " ".join(reordered_tokens)
            if is_safe_reordering(command, reordered_cmd):
                reorderings.append(reordered_cmd)

    # General reordering strategies
    # Strategy 3: Reorder arguments while keeping cmd first
    if len(tokens) >= 3:
        # Get the command (first token)
        cmd = tokens[0]
        # Get the arguments (remaining tokens)
        args = tokens[1:]
        
        # Try different orderings of arguments
        for i in range(len(args)):
            for j in range(i + 1, len(args)):
                reordered_tokens = [cmd] + args.copy()
                # Swap arguments
                reordered_tokens[i+1], reordered_tokens[j+1] = reordered_tokens[j+1], reordered_tokens[i+1]
                reordered_cmd = " ".join(reordered_tokens)
                if is_safe_reordering(command, reordered_cmd):
                    reorderings.append(reordered_cmd)

    return reorderings

def evasive_reordering(command: str) -> str:
    """
    Return one evasive command generated by a random reordering technique.
    """
    reorderings = generate_reorderings(command)
    return random.choice(reorderings) if reorderings else command
