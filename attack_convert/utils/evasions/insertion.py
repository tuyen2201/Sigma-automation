import random

def generate_insertions(command: str) -> list[str]:
    """
    Generate multiple evasive variants using insertion techniques.
    These include inserting comments, quotes, shell-escape symbols, etc.
    """
    if not command:
        return []

    insertions = []

    tokens = command.split()
    if len(tokens) < 2:
        return [command + " # inserted"]

    # Strategy 1: Insert comment after executable
    insertions.append(f"{tokens[0]} #inserted " + " ".join(tokens[1:]))

    # Strategy 2: Insert comment mid-command
    mid = len(tokens) // 2
    insertions.append(" ".join(tokens[:mid]) + " #injected " + " ".join(tokens[mid:]))

    # Strategy 3: Insert noise at the beginning
    insertions.append("#hijack " + command)

    # Strategy 4: Wrap the rest in quotes
    insertions.append(tokens[0] + " \"" + " ".join(tokens[1:]) + "\"")

    # Strategy 5: Insert shell escape characters (Windows CMD style)
    insertions.append(command.replace(" ", " ^ "))

    # Strategy 6: Insert newlines (can break some detectors)
    insertions.append(command.replace(" ", "\n"))

    # Strategy 7: Insert tabs (can bypass strict parsers)
    insertions.append(command.replace(" ", "\t"))

    # Strategy 8: Break into segments with &&
    if len(tokens) >= 3:
        seg1 = " ".join(tokens[:2])
        seg2 = " ".join(tokens[2:])
        insertions.append(f"{seg1} && {seg2}")

    return insertions


def evasive_insertion(command: str) -> str:
    """
    Return one evasive command generated by a random insertion technique.
    """
    evasions = generate_insertions(command)
    return random.choice(evasions) if evasions else command
